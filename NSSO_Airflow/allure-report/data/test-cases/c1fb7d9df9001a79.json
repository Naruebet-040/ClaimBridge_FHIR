{"uid":"c1fb7d9df9001a79","name":"test_task_dependencies","fullName":"dags.tests.test_example_allure_report#test_task_dependencies","historyId":"1391b8722dd50c33f493502b94469e8f","time":{"start":1744375919392,"stop":1744375919394,"duration":2},"description":"Test if the task dependencies are correctly set","descriptionHtml":"<p>Test if the task dependencies are correctly set</p>\n","status":"broken","statusMessage":"sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: dag\n[SQL: SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parsed_time, dag.last_pickled, dag.last_expired, dag.scheduler_lock, dag.pickle_id, dag.fileloc, dag.processor_subdir, dag.owners, dag.description, dag.default_view, dag.schedule_interval, dag.timetable_description, dag.dataset_expression, dag.max_active_tasks, dag.max_active_runs, dag.max_consecutive_failed_dag_runs, dag.has_task_concurrency_limits, dag.has_import_errors, dag.next_dagrun, dag.next_dagrun_data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \nFROM dag \nWHERE dag.dag_id = ?]\n[parameters: ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)]\n(Background on this error at: https://sqlalche.me/e/14/e3q8)","statusTrace":"self = <sqlalchemy.future.engine.Connection object at 0x000001ADE951AC90>\ndialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001ADE7D388C0>\nconstructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>\nstatement = 'SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parse...data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \\nFROM dag \\nWHERE dag.dag_id = ?'\nparameters = ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)\nexecution_options = immutabledict({'_result_disable_adapt_to_context': True, 'future_result': True})\nargs = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001ADE8E66510>, [{}], <sqlalchemy.sql.selectable.Selec...indParameter('%(1846455270672 dag_id)s', 'mongo_fhir_data_fetcher_multiple_dbs_sequential', type_=String(length=250))])\nkw = {'cache_hit': symbol('CACHE_HIT')}, branched = <sqlalchemy.future.engine.Connection object at 0x000001ADE951AC90>\nyp = None, conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x000001ADE951BE30>\ncontext = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001ADE951BF80>\ncursor = <sqlite3.Cursor object at 0x000001ADE9598440>, evt_handled = False\n\n    def _execute_context(\n        self,\n        dialect,\n        constructor,\n        statement,\n        parameters,\n        execution_options,\n        *args,\n        **kw\n    ):\n        \"\"\"Create an :class:`.ExecutionContext` and execute, returning\n        a :class:`_engine.CursorResult`.\"\"\"\n    \n        branched = self\n        if self.__branch_from:\n            # if this is a \"branched\" connection, do everything in terms\n            # of the \"root\" connection, *except* for .close(), which is\n            # the only feature that branching provides\n            self = self.__branch_from\n    \n        if execution_options:\n            yp = execution_options.get(\"yield_per\", None)\n            if yp:\n                execution_options = execution_options.union(\n                    {\"stream_results\": True, \"max_row_buffer\": yp}\n                )\n    \n        try:\n            conn = self._dbapi_connection\n            if conn is None:\n                conn = self._revalidate_connection()\n    \n            context = constructor(\n                dialect, self, conn, execution_options, *args, **kw\n            )\n        except (exc.PendingRollbackError, exc.ResourceClosedError):\n            raise\n        except BaseException as e:\n            self._handle_dbapi_exception(\n                e, util.text_type(statement), parameters, None, None\n            )\n    \n        if (\n            self._transaction\n            and not self._transaction.is_active\n            or (\n                self._nested_transaction\n                and not self._nested_transaction.is_active\n            )\n        ):\n            self._invalid_transaction()\n    \n        elif self._trans_context_manager:\n            TransactionalContext._trans_ctx_check(self)\n    \n        if self._is_future and self._transaction is None:\n            self._autobegin()\n    \n        context.pre_exec()\n    \n        if dialect.use_setinputsizes:\n            context._set_input_sizes()\n    \n        cursor, statement, parameters = (\n            context.cursor,\n            context.statement,\n            context.parameters,\n        )\n    \n        if not context.executemany:\n            parameters = parameters[0]\n    \n        if self._has_events or self.engine._has_events:\n            for fn in self.dispatch.before_cursor_execute:\n                statement, parameters = fn(\n                    self,\n                    cursor,\n                    statement,\n                    parameters,\n                    context,\n                    context.executemany,\n                )\n    \n        if self._echo:\n    \n            self._log_info(statement)\n    \n            stats = context._get_cache_stats()\n    \n            if not self.engine.hide_parameters:\n                self._log_info(\n                    \"[%s] %r\",\n                    stats,\n                    sql_util._repr_params(\n                        parameters, batches=10, ismulti=context.executemany\n                    ),\n                )\n            else:\n                self._log_info(\n                    \"[%s] [SQL parameters hidden due to hide_parameters=True]\"\n                    % (stats,)\n                )\n    \n        evt_handled = False\n        try:\n            if context.executemany:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_executemany:\n                        if fn(cursor, statement, parameters, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_executemany(\n                        cursor, statement, parameters, context\n                    )\n            elif not parameters and context.no_parameters:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute_no_params:\n                        if fn(cursor, statement, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute_no_params(\n                        cursor, statement, context\n                    )\n            else:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute:\n                        if fn(cursor, statement, parameters, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n>                   self.dialect.do_execute(\n                        cursor, statement, parameters, context\n                    )\n\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1910: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001ADE7D388C0>\ncursor = <sqlite3.Cursor object at 0x000001ADE9598440>\nstatement = 'SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parse...data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \\nFROM dag \\nWHERE dag.dag_id = ?'\nparameters = ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)\ncontext = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001ADE951BF80>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       sqlite3.OperationalError: no such table: dag\n\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:736: OperationalError\n\nThe above exception was the direct cause of the following exception:\n\ndagbag = <airflow.models.dagbag.DagBag object at 0x000001ADE94F7440>\n\n    def test_task_dependencies(dagbag):\n        \"\"\"Test if the task dependencies are correctly set\"\"\"\n>       dag = dagbag.get_dag(\"mongo_fhir_data_fetcher_multiple_dbs_sequential\")\n\ndags\\tests\\test_example_allure_report.py:79: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\utils\\session.py:97: in wrapper\n    return func(*args, session=session, **kwargs)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\models\\dagbag.py:267: in get_dag\n    orm_dag = DagModel.get_current(root_dag_id, session=session)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\api_internal\\internal_api_call.py:166: in wrapper\n    return func(*args, **kwargs)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\utils\\session.py:94: in wrapper\n    return func(*args, **kwargs)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\models\\dag.py:3950: in get_current\n    return session.scalar(select(cls).where(cls.dag_id == dag_id))\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1747: in scalar\n    return self.execute(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1717: in execute\n    result = conn._execute_20(statement, params or {}, execution_options)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1710: in _execute_20\n    return meth(self, args_10style, kwargs_10style, execution_options)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\sql\\elements.py:334: in _execute_on_connection\n    return connection._execute_clauseelement(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1577: in _execute_clauseelement\n    ret = self._execute_context(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1953: in _execute_context\n    self._handle_dbapi_exception(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:2134: in _handle_dbapi_exception\n    util.raise_(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\util\\compat.py:211: in raise_\n    raise exception\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1910: in _execute_context\n    self.dialect.do_execute(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001ADE7D388C0>\ncursor = <sqlite3.Cursor object at 0x000001ADE9598440>\nstatement = 'SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parse...data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \\nFROM dag \\nWHERE dag.dag_id = ?'\nparameters = ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)\ncontext = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001ADE951BF80>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: dag\nE       [SQL: SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parsed_time, dag.last_pickled, dag.last_expired, dag.scheduler_lock, dag.pickle_id, dag.fileloc, dag.processor_subdir, dag.owners, dag.description, dag.default_view, dag.schedule_interval, dag.timetable_description, dag.dataset_expression, dag.max_active_tasks, dag.max_active_runs, dag.max_consecutive_failed_dag_runs, dag.has_task_concurrency_limits, dag.has_import_errors, dag.next_dagrun, dag.next_dagrun_data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \nE       FROM dag \nE       WHERE dag.dag_id = ?]\nE       [parameters: ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)]\nE       (Background on this error at: https://sqlalche.me/e/14/e3q8)\n\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:736: OperationalError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"dagbag","time":{"start":1744375919354,"stop":1744375919391,"duration":37},"status":"passed","steps":[],"attachments":[],"parameters":[],"hasContent":false,"shouldDisplayMessage":false,"attachmentsCount":0,"stepsCount":0,"attachmentStep":false}],"testStage":{"description":"Test if the task dependencies are correctly set","status":"broken","statusMessage":"sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: dag\n[SQL: SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parsed_time, dag.last_pickled, dag.last_expired, dag.scheduler_lock, dag.pickle_id, dag.fileloc, dag.processor_subdir, dag.owners, dag.description, dag.default_view, dag.schedule_interval, dag.timetable_description, dag.dataset_expression, dag.max_active_tasks, dag.max_active_runs, dag.max_consecutive_failed_dag_runs, dag.has_task_concurrency_limits, dag.has_import_errors, dag.next_dagrun, dag.next_dagrun_data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \nFROM dag \nWHERE dag.dag_id = ?]\n[parameters: ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)]\n(Background on this error at: https://sqlalche.me/e/14/e3q8)","statusTrace":"self = <sqlalchemy.future.engine.Connection object at 0x000001ADE951AC90>\ndialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001ADE7D388C0>\nconstructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext'>>\nstatement = 'SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parse...data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \\nFROM dag \\nWHERE dag.dag_id = ?'\nparameters = ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)\nexecution_options = immutabledict({'_result_disable_adapt_to_context': True, 'future_result': True})\nargs = (<sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000001ADE8E66510>, [{}], <sqlalchemy.sql.selectable.Selec...indParameter('%(1846455270672 dag_id)s', 'mongo_fhir_data_fetcher_multiple_dbs_sequential', type_=String(length=250))])\nkw = {'cache_hit': symbol('CACHE_HIT')}, branched = <sqlalchemy.future.engine.Connection object at 0x000001ADE951AC90>\nyp = None, conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x000001ADE951BE30>\ncontext = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001ADE951BF80>\ncursor = <sqlite3.Cursor object at 0x000001ADE9598440>, evt_handled = False\n\n    def _execute_context(\n        self,\n        dialect,\n        constructor,\n        statement,\n        parameters,\n        execution_options,\n        *args,\n        **kw\n    ):\n        \"\"\"Create an :class:`.ExecutionContext` and execute, returning\n        a :class:`_engine.CursorResult`.\"\"\"\n    \n        branched = self\n        if self.__branch_from:\n            # if this is a \"branched\" connection, do everything in terms\n            # of the \"root\" connection, *except* for .close(), which is\n            # the only feature that branching provides\n            self = self.__branch_from\n    \n        if execution_options:\n            yp = execution_options.get(\"yield_per\", None)\n            if yp:\n                execution_options = execution_options.union(\n                    {\"stream_results\": True, \"max_row_buffer\": yp}\n                )\n    \n        try:\n            conn = self._dbapi_connection\n            if conn is None:\n                conn = self._revalidate_connection()\n    \n            context = constructor(\n                dialect, self, conn, execution_options, *args, **kw\n            )\n        except (exc.PendingRollbackError, exc.ResourceClosedError):\n            raise\n        except BaseException as e:\n            self._handle_dbapi_exception(\n                e, util.text_type(statement), parameters, None, None\n            )\n    \n        if (\n            self._transaction\n            and not self._transaction.is_active\n            or (\n                self._nested_transaction\n                and not self._nested_transaction.is_active\n            )\n        ):\n            self._invalid_transaction()\n    \n        elif self._trans_context_manager:\n            TransactionalContext._trans_ctx_check(self)\n    \n        if self._is_future and self._transaction is None:\n            self._autobegin()\n    \n        context.pre_exec()\n    \n        if dialect.use_setinputsizes:\n            context._set_input_sizes()\n    \n        cursor, statement, parameters = (\n            context.cursor,\n            context.statement,\n            context.parameters,\n        )\n    \n        if not context.executemany:\n            parameters = parameters[0]\n    \n        if self._has_events or self.engine._has_events:\n            for fn in self.dispatch.before_cursor_execute:\n                statement, parameters = fn(\n                    self,\n                    cursor,\n                    statement,\n                    parameters,\n                    context,\n                    context.executemany,\n                )\n    \n        if self._echo:\n    \n            self._log_info(statement)\n    \n            stats = context._get_cache_stats()\n    \n            if not self.engine.hide_parameters:\n                self._log_info(\n                    \"[%s] %r\",\n                    stats,\n                    sql_util._repr_params(\n                        parameters, batches=10, ismulti=context.executemany\n                    ),\n                )\n            else:\n                self._log_info(\n                    \"[%s] [SQL parameters hidden due to hide_parameters=True]\"\n                    % (stats,)\n                )\n    \n        evt_handled = False\n        try:\n            if context.executemany:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_executemany:\n                        if fn(cursor, statement, parameters, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_executemany(\n                        cursor, statement, parameters, context\n                    )\n            elif not parameters and context.no_parameters:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute_no_params:\n                        if fn(cursor, statement, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute_no_params(\n                        cursor, statement, context\n                    )\n            else:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute:\n                        if fn(cursor, statement, parameters, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n>                   self.dialect.do_execute(\n                        cursor, statement, parameters, context\n                    )\n\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1910: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001ADE7D388C0>\ncursor = <sqlite3.Cursor object at 0x000001ADE9598440>\nstatement = 'SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parse...data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \\nFROM dag \\nWHERE dag.dag_id = ?'\nparameters = ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)\ncontext = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001ADE951BF80>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       sqlite3.OperationalError: no such table: dag\n\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:736: OperationalError\n\nThe above exception was the direct cause of the following exception:\n\ndagbag = <airflow.models.dagbag.DagBag object at 0x000001ADE94F7440>\n\n    def test_task_dependencies(dagbag):\n        \"\"\"Test if the task dependencies are correctly set\"\"\"\n>       dag = dagbag.get_dag(\"mongo_fhir_data_fetcher_multiple_dbs_sequential\")\n\ndags\\tests\\test_example_allure_report.py:79: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\utils\\session.py:97: in wrapper\n    return func(*args, session=session, **kwargs)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\models\\dagbag.py:267: in get_dag\n    orm_dag = DagModel.get_current(root_dag_id, session=session)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\api_internal\\internal_api_call.py:166: in wrapper\n    return func(*args, **kwargs)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\utils\\session.py:94: in wrapper\n    return func(*args, **kwargs)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\airflow\\models\\dag.py:3950: in get_current\n    return session.scalar(select(cls).where(cls.dag_id == dag_id))\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1747: in scalar\n    return self.execute(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1717: in execute\n    result = conn._execute_20(statement, params or {}, execution_options)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1710: in _execute_20\n    return meth(self, args_10style, kwargs_10style, execution_options)\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\sql\\elements.py:334: in _execute_on_connection\n    return connection._execute_clauseelement(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1577: in _execute_clauseelement\n    ret = self._execute_context(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1953: in _execute_context\n    self._handle_dbapi_exception(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:2134: in _handle_dbapi_exception\n    util.raise_(\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\util\\compat.py:211: in raise_\n    raise exception\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1910: in _execute_context\n    self.dialect.do_execute(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001ADE7D388C0>\ncursor = <sqlite3.Cursor object at 0x000001ADE9598440>\nstatement = 'SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parse...data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \\nFROM dag \\nWHERE dag.dag_id = ?'\nparameters = ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)\ncontext = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001ADE951BF80>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: dag\nE       [SQL: SELECT dag.dag_display_name, dag.dag_id, dag.root_dag_id, dag.is_paused, dag.is_subdag, dag.is_active, dag.last_parsed_time, dag.last_pickled, dag.last_expired, dag.scheduler_lock, dag.pickle_id, dag.fileloc, dag.processor_subdir, dag.owners, dag.description, dag.default_view, dag.schedule_interval, dag.timetable_description, dag.dataset_expression, dag.max_active_tasks, dag.max_active_runs, dag.max_consecutive_failed_dag_runs, dag.has_task_concurrency_limits, dag.has_import_errors, dag.next_dagrun, dag.next_dagrun_data_interval_start, dag.next_dagrun_data_interval_end, dag.next_dagrun_create_after \nE       FROM dag \nE       WHERE dag.dag_id = ?]\nE       [parameters: ('mongo_fhir_data_fetcher_multiple_dbs_sequential',)]\nE       (Background on this error at: https://sqlalche.me/e/14/e3q8)\n\nC:\\Users\\narub\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:736: OperationalError","steps":[],"attachments":[{"uid":"484fb1702dbc799d","name":"log","source":"484fb1702dbc799d.txt","type":"text/plain","size":92},{"uid":"8e94e4b97b053f64","name":"stdout","source":"8e94e4b97b053f64.txt","type":"text/plain","size":86}],"parameters":[],"hasContent":true,"shouldDisplayMessage":true,"attachmentsCount":2,"stepsCount":0,"attachmentStep":false},"afterStages":[],"labels":[{"name":"parentSuite","value":"dags.tests"},{"name":"suite","value":"test_example_allure_report"},{"name":"host","value":"MSI"},{"name":"thread","value":"80560-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"dags.tests.test_example_allure_report"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Test defects","matchedStatuses":[]}],"tags":[]},"source":"c1fb7d9df9001a79.json","parameterValues":[]}